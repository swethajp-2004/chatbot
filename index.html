<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>BUNDLE AI</title>
  <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap" rel="stylesheet">

  <style>
    * { box-sizing: border-box; font-family:'Inter',sans-serif; }
    :root{
      /* Light palette: white + soft blues */
      --sidebar-bg1: #ffffff;
      --sidebar-bg2: #f3f4f6;
      --accent: #3b82f6;
      --accent-soft: #93c5fd;
      --muted: #64748b;
      --panel: #f1f5f9;
      --card: #ffffff;
      --surface: #f8fafc;
      --border-soft: #e2e8f0;
    }

    body {
      margin:0;
      height:100vh;
      display:flex;
      background:
        radial-gradient(circle at 0% 0%, rgba(129,140,248,0.12), transparent 55%),
        radial-gradient(circle at 100% 100%, rgba(56,189,248,0.10), transparent 55%),
        linear-gradient(180deg,#f9fbff 0%, #eef4ff 100%);
      color:#0f172a;
    }

    /* Sidebar */
    .sidebar {
      width:320px;
      background: linear-gradient(180deg,var(--sidebar-bg1), var(--sidebar-bg2));
      color:#0f172a;
      display:flex;
      flex-direction:column;
      padding:20px;
      gap:12px;
      box-shadow: 4px 0 18px rgba(15,23,42,0.08);
    }

    .provider-btn {
      width: 100%;
      background: linear-gradient(135deg, #93c5fd, #60a5fa);
      color: #0f172a;
      border: none;
      padding: 12px;
      margin-top: 10px;
      border-radius: 12px;
      font-weight: 600;
      cursor: pointer;
      text-align: left;
      box-shadow: 0 6px 12px rgba(148,163,184,0.35);
      transition: all 0.15s ease-in-out;
    }
    .provider-btn:hover {
      transform: translateY(-2px);
      background: linear-gradient(135deg, #60a5fa, #3b82f6);
      box-shadow: 0 10px 18px rgba(148,163,184,0.45);
    }

    .brand { display:flex; align-items:center; gap:12px; }
    .brand .logo {
      width:56px; height:56px; border-radius:16px;
      overflow:hidden; display:flex; align-items:center; justify-content:center;
      background: radial-gradient(circle at 0% 0%, #bfdbfe, #dbeafe);
      box-shadow: 0 6px 14px rgba(148,163,184,0.5);
      flex-shrink:0;
    }
    .brand .logo img{ width:100%; height:100%; object-fit:contain; display:block; }
    .brand .title { display:flex; flex-direction:column; }
    .brand .title .h { font-weight:700; font-size:1.05rem; letter-spacing:0.6px; color:#1f2937; }
    .brand .title .sub { font-size:0.82rem; color:#6b7280; margin-top:4px; }

    .chats { overflow-y:auto; flex:1; margin-top:6px; padding-right:6px; }
    .chat-item {
      padding:12px;
      border-radius:12px;
      margin-bottom:10px;
      cursor:pointer;
      background:#f3f4f6;
      border:1px solid rgba(148,163,184,0.6);
      display:flex; justify-content:space-between; align-items:center; gap:12px;
      transition:all .14s;
    }
    .chat-item.active {
      background:linear-gradient(135deg, rgba(191,219,254,0.8), rgba(219,234,254,0.95));
      border-color: rgba(147,197,253,1);
      box-shadow: 0 8px 18px rgba(148,163,184,0.4);
    }
    .chat-item:hover {
      transform:translateY(-1px);
      border-color: rgba(148,163,184,1);
    }
    .chat-meta { display:flex; flex-direction:column; flex:1; min-width:0; }
    .chat-title { font-weight:600; color:#0f172a; white-space:nowrap; overflow:hidden; text-overflow:ellipsis; font-size:0.95rem; }
    .chat-time { color:#6b7280; font-size:0.82rem; margin-top:4px; }
    .chat-controls { display:flex; gap:8px; opacity:0; transition:opacity .12s; align-items:center; }
    .chat-item:hover .chat-controls { opacity:1; }
    .icon-btn {
      background:#e5e7eb;
      border:1px solid rgba(148,163,184,0.7);
      color:#1f2937;
      padding:6px;
      border-radius:999px;
      cursor:pointer;
      display:inline-flex; align-items:center; justify-content:center;
    }
    .icon-btn.del { color:#b91c1c; border-color:rgba(248,113,113,0.7); }

    /* Main area */
    .main { flex:1; display:flex; flex-direction:column; }

    header {
      background: linear-gradient(90deg,#3b82f6 0%, #60a5fa 40%, #bfdbfe 100%);
      color:white;
      padding:18px 24px;
      display:flex;
      align-items:center;
      gap:18px;
      box-shadow: 0 8px 20px rgba(148,163,184,0.45);
    }
    header .top-left { display:flex; align-items:center; gap:12px; }
    header .title {
      font-size:1.25rem;
      font-weight:700;
      letter-spacing:0.12em;
      color:#eff6ff;
      text-transform:uppercase;
    }

    .content {
      display:flex;
      flex-direction:column;
      gap:12px;
      padding:22px;
      height: calc(100vh - 120px);
      overflow:auto;
      align-items:center;
      background:linear-gradient(180deg,#f8fafc 0%, #e5f0ff 100%);
    }
    .chat-column {
      width:100%;
      max-width:1100px;
      display:flex;
      flex-direction:column;
      gap:16px;
    }

    .chat-message { display:flex; flex-direction:column; position:relative; }

    /* User bubble – light, subtle gradient */
    .user {
      align-self:flex-end;
      background:linear-gradient(135deg,#dbeafe,#e0f2fe);
      color:#0f172a;
      padding:12px 16px;
      border-radius:16px 16px 8px 16px;
      max-width:78%;
      white-space:pre-wrap;
      word-break:break-word;
      box-shadow: 0 4px 10px rgba(148,163,184,0.35);
    }

    /* Bot bubble – white card with soft gradient border */
    .bot {
      background:var(--card);
      color:#0f172a;
      border-radius:14px;
      padding:18px;
      max-width:100%;
      border:1px solid var(--border-soft);
      box-shadow: 0 6px 16px rgba(148,163,184,0.3);
      position:relative;
      overflow:hidden;
    }
    .bot::before{
      content:'';
      position:absolute;
      inset:-1px;
      border-radius:14px;
      padding:1px;
      background:linear-gradient(135deg,rgba(59,130,246,0.3),rgba(129,140,248,0.25),rgba(45,212,191,0.25));
      -webkit-mask:linear-gradient(#000 0 0) content-box, linear-gradient(#000 0 0);
      -webkit-mask-composite: xor;
              mask-composite: exclude;
      opacity:0.7;
      pointer-events:none;
    }
    .bot strong { color:var(--accent); }
    .bot img {
      max-width:100%;
      border-radius:10px;
      margin-top:12px;
      display:block;
      margin-left:auto;
      margin-right:auto;
      box-shadow: 0 4px 12px rgba(148,163,184,0.5);
      background:linear-gradient(135deg,#eff6ff,#e0f2fe);
      padding:4px;
    }
    .bot table { width:100%; border-collapse:collapse; margin-top:12px; }
    .bot table, .bot th, .bot td { border:1px solid #e2e8f0; }
    .bot th, .bot td {
      padding:8px 10px;
      text-align:left;
      font-size:0.95rem;
      background:#f8fafc;
      color:#0f172a;
    }

    footer {
      padding:14px;
      background:#ffffff;
      border-top:1px solid #e2e8f0;
      display:flex;
      gap:10px;
      align-items:center;
      justify-content:center;
      position:sticky;
      bottom:0;
    }
    #user-input {
      flex:1;
      padding:12px 14px;
      border-radius:999px;
      border:1px solid #cbd5e1;
      font-size:1rem;
      box-shadow: inset 0 1px 0 rgba(255,255,255,0.8);
      background:#f9fafb;
      color:#0f172a;
    }
    #user-input::placeholder{
      color:#9ca3af;
    }

    #send-btn {
      background:linear-gradient(120deg,#60a5fa,#a5b4fc);
      background-size:140% 140%;
      color:#0f172a;
      border:none;
      padding:10px 18px;
      border-radius:999px;
      cursor:pointer;
      font-weight:600;
      letter-spacing:0.03em;
      text-transform:uppercase;
      font-size:0.85rem;
      box-shadow: 0 6px 14px rgba(96,165,250,0.5);
      transition:all .18s;
    }
    #send-btn:hover {
      transform:translateY(-1px);
      background-position:100% 0;
      box-shadow: 0 8px 18px rgba(96,165,250,0.6);
    }

    /* per-message controls (icons) */
    .msg-controls {
      position: absolute;
      top: 6px;
      right: -6px;
      display:flex;
      gap:8px;
      opacity:0;
      transition:opacity .12s;
      z-index:5;
    }
    .chat-message:hover .msg-controls { opacity:1; }
    .msg-btn {
      background:#ffffff;
      border:1px solid #cbd5e1;
      padding:6px;
      border-radius:999px;
      cursor:pointer;
      display:inline-flex;
      align-items:center;
      justify-content:center;
      width:34px; height:30px;
      box-shadow:0 4px 10px rgba(148,163,184,0.45);
    }
    .msg-btn svg { width:16px; height:16px; display:block; }

    .msg-btn.small { width:30px; height:30px; padding:4px; }

    .bot-content {
      white-space: pre-wrap;
      word-break: break-word;
      line-height:1.5;
      color:#0f172a;
    }
    .bot-table { margin-top:8px; overflow-x:auto; }

    /* download pill style inside bot messages */
    .bot .download-pill {
      display:inline-block;
      margin-top:10px;
      padding:7px 12px;
      border-radius:999px;
      border:1px solid #cbd5e1;
      font-size:0.85rem;
      text-decoration:none;
      background:#f8fafc;
      color:#0f172a;
      box-shadow:0 3px 8px rgba(148,163,184,0.35);
    }
    .bot .download-pill:hover {
      background:#e5f0ff;
    }

    /* Sample run pill under sample user messages */
    .run-pill{
      margin-top:10px;
      align-self:flex-start;
      background:#ffffff;
      border:1px solid #cbd5e1;
      padding:10px 12px;
      border-radius:999px;
      cursor:pointer;
      display:inline-flex;
      align-items:center;
      gap:10px;
      width:100%;
      box-shadow:0 8px 20px rgba(148,163,184,0.35);
      color:#0f172a;
      transition:transform .12s, box-shadow .12s, background .12s;
      user-select:none;
    }
    .run-pill:hover{
      transform:translateY(-1px);
      background:#f8fafc;
      box-shadow:0 10px 24px rgba(148,163,184,0.45);
    }
    .run-pill svg{ width:18px; height:18px; }

    /* responsive */
    @media (max-width:900px){
      .sidebar{display:none;}
      .chat-column{max-width:100%; padding:0 12px;}
      .main header{padding:14px;}
    }
  </style>
</head>
<body>
  <div class="sidebar">
    <div class="brand">
      <div class="logo">
        <img src="/static/bundle_logo.png" alt="Bundle AI logo" />
      </div>
      <div class="title">
        <div id="sidebar-app-title" class="h">BUNDLE AI</div>
        <div class="sub">Smart enterprise analytics</div>
      </div>
    </div>

    <!-- Sample Questions button -->
    <button id="sample-btn" class="provider-btn">Sample questions you can ask</button>

    <div id="chats" class="chats"></div>
    <div style="font-size:0.8rem;color:#6b7280;margin-top:8px;">BundleAI can make mistakes. Check important information before using the answer.</div>
  </div>

  <div class="main">
    <header>
      <div class="top-left">
        <div id="top-header" class="title">BUNDLE AI</div>
      </div>
    </header>

    <div class="content">
      <div class="chat-column" id="chat-column">
        <!-- messages appended here -->
      </div>
    </div>

    <footer>
      <input id="user-input" placeholder="Ask your question to Bundle AI..." autocomplete="off" />
      <button id="send-btn">Ask</button>
    </footer>
  </div>

<script>
  // ---- State ----
  let currentChatId = null;
  let chatsIndex = {}; // id -> meta (only persisted/visible chats)
  let messagesCache = {}; // id -> array of messages (each: {role, text, table_html, plot_data_uri, time})
  const ephemeralChats = new Set();

  // Sample chat id must match server.py
  const SAMPLE_CHAT_ID = "sample-chat";

  const chatsEl = document.getElementById('chats');
  const chatColumn = document.getElementById('chat-column');
  const input = document.getElementById('user-input');
  const sendBtn = document.getElementById('send-btn');
  const topHeader = document.getElementById('top-header');
  const sampleBtn = document.getElementById('sample-btn');

  function formatDate(ts){ const d = new Date(Number(ts)); return isNaN(d.getTime()) ? '' : d.toLocaleString(); }
  function escapeHtml(s){ return (s||'').replace(/&/g,'&amp;').replace(/</g,'&lt;').replace(/>/g,'&gt;'); }

  // Session id helpers (kept as before)
  function uuidv4() {
    return 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace(/[xy]/g, function(c) {
      const r = Math.random() * 16 | 0, v = c === 'x' ? r : (r & 0x3 | 0x8);
      return v.toString(16);
    });
  }
  function getCookie(name) {
    const m = document.cookie.match(new RegExp('(^| )' + name + '=([^;]+)'));
    return m ? decodeURIComponent(m[2]) : null;
  }
  function setCookie(name, value, days=365) {
    const d = new Date(); d.setTime(d.getTime() + (days*24*60*60*1000));
    const secure = location.protocol === 'https:' ? ';Secure' : '';
    document.cookie = `${name}=${encodeURIComponent(value)};path=/;expires=${d.toUTCString()};SameSite=Lax${secure}`;
  }

  function getSessionId() {
    let sid = getCookie('sid');
    if (!sid) {
      sid = uuidv4();
      setCookie('sid', sid, 365);
    }
    return sid;
  }
  const SESSION_ID = getSessionId();

  function setTopHeaderTitle(title){
    try {
      if(!topHeader) return;
      topHeader.textContent = title || 'New Chat';
    } catch(e){
      console.warn('setTopHeaderTitle failed', e);
    }
  }

  // Render chat list (ephemeral filtered) + IMPORTANT: HIDE SAMPLE CHAT ITEM (so you don't see 2)
  function renderChatList(){
    chatsEl.innerHTML = '';
    const list = Object.values(chatsIndex).sort((a,b)=> (b.created_at||0) - (a.created_at||0));
    list.forEach(meta=>{
      if(!meta || !meta.id) return;
      if(ephemeralChats.has(meta.id)) return;

      // ✅ DON’T render sample chat here — only access it via the button
      if(meta.id === SAMPLE_CHAT_ID) return;

      const item = document.createElement('div');
      item.className = 'chat-item' + (meta.id===currentChatId ? ' active' : '');
      const metaDiv = document.createElement('div'); metaDiv.className='chat-meta';

      const titleDiv = document.createElement('div'); titleDiv.className='chat-title'; titleDiv.title = meta.title || 'Chat';
      titleDiv.innerText = meta.title || 'Chat';

      const tdiv = document.createElement('div'); tdiv.className='chat-time'; tdiv.innerText = meta.created_at ? formatDate(meta.created_at) : '';
      metaDiv.appendChild(titleDiv); metaDiv.appendChild(tdiv);

      const controls = document.createElement('div'); controls.className='chat-controls';

      const renameBtn = document.createElement('button'); renameBtn.className='icon-btn'; renameBtn.title='Rename';
      renameBtn.innerHTML = '<svg viewBox="0 0 24 24" width="16" height="16" fill="none" xmlns="http://www.w3.org/2000/svg"><path d="M3 17.25V21h3.75L17.81 9.94l-3.75-3.75L3 17.25z" fill="#1f2937"/><path d="M20.71 7.04a1 1 0 0 0 0-1.41l-2.34-2.34a1 1 0 0 0-1.41 0l-1.83 1.83 3.75 3.75 1.83-1.83z" fill="#1f2937"/></svg>';
      renameBtn.onclick = (ev)=>{ ev.stopPropagation(); renameChat(meta.id); };

      const delBtn = document.createElement('button'); delBtn.className='icon-btn del'; delBtn.title='Delete';
      delBtn.innerHTML = '<svg viewBox="0 0 24 24" width="16" height="16" fill="none" xmlns="http://www.w3.org/2000/svg"><path d="M6 7h12" stroke="#b91c1c" stroke-width="1.6" stroke-linecap="round"/><path d="M9 7V5a2 2 0 0 1 2-2h2a2 2 0 0 1 2 2v2" stroke="#b91c1c" stroke-width="1.6" stroke-linecap="round"/><path d="M19 7l-1 13a2 2 0 0 1-2 2H8a2 2 0 0 1-2-2L5 7" stroke="#b91c1c" stroke-width="1.6" stroke-linecap="round" stroke-linejoin="round"/></svg>';
      delBtn.onclick = (ev)=>{ ev.stopPropagation(); deleteChat(meta.id); };

      controls.appendChild(renameBtn);
      controls.appendChild(delBtn);

      item.appendChild(metaDiv);
      item.appendChild(controls);
      item.onclick = ()=> loadConversation(meta.id);
      chatsEl.appendChild(item);
    });
  }

  function createMessageElement(msg, index){
    const wrapper = document.createElement('div');
    wrapper.className = 'chat-message';

    const controls = document.createElement('div');
    controls.className = 'msg-controls';

    // COPY button
    const copyBtn = document.createElement('button');
    copyBtn.className = 'msg-btn copy small';
    copyBtn.title = (msg.role === 'user') ? 'Copy question' : 'Copy answer';
    copyBtn.innerHTML = '<svg viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg"><rect x="9" y="9" width="10" height="10" rx="2" stroke="#2563eb" stroke-width="1.4"/><rect x="4" y="4" width="10" height="10" rx="2" stroke="#2563eb" stroke-width="1.4"/></svg>';
    copyBtn.onclick = (ev) => {
      ev.stopPropagation();
      const textToCopy = msg.text || '';
      navigator.clipboard.writeText(textToCopy).then(()=> {
        const n = document.createElement('div');
        n.textContent = (msg.role === 'user') ? 'Question copied' : 'Answer copied';
        n.style.position='fixed'; n.style.right='20px'; n.style.bottom='24px';
        n.style.padding='8px 12px'; n.style.background='#0f172a'; n.style.color='#fff'; n.style.borderRadius='8px';
        n.style.boxShadow='0 6px 18px rgba(15,23,42,0.5)'; document.body.appendChild(n);
        setTimeout(()=> n.remove(), 1200);
      }, (err)=> {
        alert('Copy failed: ' + err);
      });
    };

    const delBtn = document.createElement('button');
    delBtn.className = 'msg-btn del small';
    delBtn.title = 'Delete message';
    delBtn.innerHTML = '<svg viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg"><path d="M3 6h18" stroke="#f97373" stroke-width="1.6" stroke-linecap="round"/><path d="M8 6v12a2 2 0 0 0 2 2h4a2 2 0 0 0 2-2V6" stroke="#f97373" stroke-width="1.6" stroke-linecap="round" stroke-linejoin="round"/><path d="M10 6V4a2 2 0 0 1 2-2h0a2 2 0 0 1 2 2v2" stroke="#f97373" stroke-width="1.6" stroke-linecap="round" stroke-linejoin="round"/></svg>';

    // Disable delete in sample chat
    delBtn.onclick = (ev) => {
      ev.stopPropagation();
      if(currentChatId === SAMPLE_CHAT_ID) return;
      handleDelete(msg, index);
    };

    controls.appendChild(copyBtn);
    controls.appendChild(delBtn);
    wrapper.appendChild(controls);

    const isSampleChat = (currentChatId === SAMPLE_CHAT_ID);

    if(msg.role === 'user'){
      const content = document.createElement('div');
      content.className = 'user';
      content.innerText = msg.text || '';
      wrapper.appendChild(content);

      // Run pill for sample questions only (and only if no bot immediately after)
      if(isSampleChat && (msg.text || '').trim()){
        const arr = messagesCache[currentChatId] || [];
        const hasBotAfter = (index + 1 < arr.length && arr[index + 1] && arr[index + 1].role === 'bot');
        if(!hasBotAfter){
          const run = document.createElement('div');
          run.className = 'run-pill';
          run.innerHTML = '<svg viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg"><path d="M8 5v14l12-7-12-7z" stroke="#2563eb" stroke-width="1.8" stroke-linejoin="round"/></svg>Run this question';
          run.onclick = (ev)=>{
            ev.stopPropagation();
            runSampleAt(index);
          };
          wrapper.appendChild(run);
        }
      }

    } else {
      const content = document.createElement('div');
      content.className = 'bot';

      // Placeholder style
      if(msg.__placeholder){
        content.style.fontStyle = 'italic';
        content.style.color = '#6b7280';
        content.style.borderStyle = 'dashed';
      }

      const title = document.createElement('div');
      title.innerHTML = `<strong>BundleAI:</strong>`;
      const body = document.createElement('div');
      body.className = 'bot-content';
      body.innerHTML = escapeHtml(msg.text || '').replace(/\n/g, '<br>');
      content.appendChild(title);
      content.appendChild(body);

      if(msg.table_html){
        const tableWrap = document.createElement('div');
        tableWrap.className = 'bot-table';
        tableWrap.innerHTML = msg.table_html;
        content.appendChild(tableWrap);
      }
      if(msg.plot_data_uri){
        const img = document.createElement('img');
        img.src = msg.plot_data_uri;
        img.alt = 'chart';
        content.appendChild(img);
      }

      if (msg.download_url) {
        const dl = document.createElement('a');
        dl.href = msg.download_url;
        dl.target = '_blank';
        dl.rel = 'noopener noreferrer';
        dl.className = 'download-pill';
        dl.textContent = 'Download as Excel';
        content.appendChild(dl);
      }

      wrapper.appendChild(content);
    }
    return wrapper;
  }

  function renderMessagesForCurrentChat(){
    chatColumn.innerHTML = '';
    const msgs = messagesCache[currentChatId] || [];
    msgs.forEach((m, idx) => {
      const el = createMessageElement(m, idx);
      chatColumn.appendChild(el);
    });
    chatColumn.scrollTop = chatColumn.scrollHeight;
  }

  // ✅ UPDATED: do NOT auto-open sample chat on load.
  // Show normal chats list, and open the newest NON-SAMPLE chat if exists.
  async function loadChatsIndex(){
    try {
      const seen = getCookie('bundle_seen_before');
      if (!seen) {
        setCookie('bundle_seen_before', '1', 365);
      }

      const res = await fetch('/memory/list?sid=' + encodeURIComponent(SESSION_ID));
      const j = await res.json();

      if(j && Array.isArray(j.chats)){
        chatsIndex = {};
        j.chats.forEach(c => chatsIndex[c.id] = c);
        // Always force sample chat meta so it never breaks / duplicates
        chatsIndex[SAMPLE_CHAT_ID] = { id: SAMPLE_CHAT_ID, title: 'Sample Questions', created_at: 1700000000000 };
        
        // Always keep sample in index (but we hide it in the sidebar list)
        if(!chatsIndex[SAMPLE_CHAT_ID]){
          chatsIndex[SAMPLE_CHAT_ID] = { id: SAMPLE_CHAT_ID, title: 'Sample Questions', created_at: 1700000000000 };
        }

        renderChatList();

        // Auto-open the newest non-sample chat, if any
        const nonSample = Object.values(chatsIndex).filter(x => x && x.id && x.id !== SAMPLE_CHAT_ID);
        if(nonSample.length){
          nonSample.sort((a,b)=> (b.created_at||0) - (a.created_at||0));
          await loadConversation(nonSample[0].id);
        } else {
          // If user has no chats, keep empty screen until they click sample button or ask a question
          currentChatId = null;
          chatColumn.innerHTML = '';
          setTopHeaderTitle('BUNDLE AI');
        }

      } else {
        renderChatList();
      }

    } catch(e){
      console.warn('loadChatsIndex failed', e);
      renderChatList();
    }
  }

  async function createNewChat(showInList = true){
    const id = 'chat-' + Date.now() + '-' + Math.random().toString(36).slice(2,8);
    currentChatId = id;
    messagesCache[id] = [];
    if(showInList){
      chatsIndex[id] = { id, title: 'New chat', created_at: Date.now() };
      await saveConversationToServer(id);
    } else {
      ephemeralChats.add(id);
    }
    renderChatList();
    renderMessagesForCurrentChat();
    setTopHeaderTitle(showInList ? (chatsIndex[id].title) : 'New Chat');
  }

  async function loadConversation(id){
    try {
      const res = await fetch('/memory/load?id=' + encodeURIComponent(id) + '&sid=' + encodeURIComponent(SESSION_ID));
      if(res.status===200){
        const j = await res.json();
        currentChatId = id;

        // Sample chat should always show ONLY the preset sample questions
        if (id === SAMPLE_CHAT_ID) {
          messagesCache[id] = Array.isArray(j.messages) ? j.messages.slice(0) : [];
        } else {
          messagesCache[id] = j.messages || [];
        }

        chatsIndex[id] = { id, title: j.title || 'Chat', created_at: j.created_at || Date.now() };
        ephemeralChats.delete(id);
        renderChatList();
        renderMessagesForCurrentChat();
        setTopHeaderTitle(chatsIndex[id].title);
      } else {
        renderChatList();
      }
    } catch(e){
      console.warn('loadConversation err', e);
      renderChatList();
    }
  }

  async function saveConversationToServer(id){
    if(ephemeralChats.has(id)) return;

    // Do not save sample chat from client
    if(id === SAMPLE_CHAT_ID) return;

    const payload = {
      sid: SESSION_ID,
      id,
      title: (chatsIndex[id] && chatsIndex[id].title) || 'Chat',
      created_at: (chatsIndex[id] && chatsIndex[id].created_at) || Date.now(),
      messages: messagesCache[id] || []
    };
    try {
      await fetch('/memory/save', {
        method:'POST', headers:{'Content-Type':'application/json'}, body: JSON.stringify(payload)
      });
      await loadChatsIndex();
    } catch(e){
      console.warn('saveConversation failed', e);
    }
  }

  async function deleteChat(id){
    if(id === SAMPLE_CHAT_ID) return;
    if(!confirm('Delete this chat? This cannot be undone from the UI.')) return;
    try {
      const res = await fetch('/memory/delete', {
        method:'POST', headers:{'Content-Type':'application/json'}, body: JSON.stringify({ id, sid: SESSION_ID })
      });
      const j = await res.json();
      if(j && j.ok){
        delete chatsIndex[id];
        delete messagesCache[id];
        ephemeralChats.delete(id);
        const keys = Object.keys(chatsIndex).filter(k=>k!==SAMPLE_CHAT_ID);
        if(keys.length) await loadConversation(keys[0]);
        else {
          currentChatId = null;
          renderChatList();
          chatColumn.innerHTML = '';
          setTopHeaderTitle('Bundle AI');
        }
      } else {
        alert('Delete failed');
      }
    } catch(e){
      console.warn('deleteChat err', e);
      alert('Delete failed');
    }
  }

  async function renameChat(id){
    if(id === SAMPLE_CHAT_ID) return;
    const meta = chatsIndex[id] || {};
    const current = meta.title || '';
    const newTitle = prompt('Rename chat', current);
    if(newTitle === null) return;
    if(ephemeralChats.has(id)){
      chatsIndex[id] = { id, title: newTitle || 'Chat', created_at: Date.now() };
      ephemeralChats.delete(id);
      await saveConversationToServer(id);
    } else {
      chatsIndex[id].title = newTitle || 'Chat';
      await saveConversationToServer(id);
    }
    renderChatList();
    setTopHeaderTitle(chatsIndex[id].title);
  }

  async function handleDelete(msg, idx){
    if(currentChatId === SAMPLE_CHAT_ID) return;
    if(!confirm('Delete this message?')) return;
    const arr = messagesCache[currentChatId] || [];
    if(!Array.isArray(arr)) return;
    if(idx < 0 || idx >= arr.length) return;

    if(arr[idx].role === 'user'){
      arr.splice(idx, 1);
      if(idx < arr.length && arr[idx].role === 'bot'){
        arr.splice(idx, 1);
      }
    } else {
      arr.splice(idx, 1);
    }
    messagesCache[currentChatId] = arr;
    const firstUser = arr.find(m => m.role === 'user');
    if(!ephemeralChats.has(currentChatId) && chatsIndex[currentChatId]){
      chatsIndex[currentChatId].title = firstUser ? (firstUser.text.slice(0,40) + (firstUser.text.length>40 ? '...' : '')) : 'Chat';
    }
    setTopHeaderTitle((chatsIndex[currentChatId] && chatsIndex[currentChatId].title) || 'Chat');
    await saveConversationToServer(currentChatId);
    renderChatList();
    renderMessagesForCurrentChat();
  }

  async function sendMessage(){
    const text = input.value.trim();
    if(!text) return;

    // If currently in sample chat, create a real new ephemeral chat for user questions
    if(currentChatId === SAMPLE_CHAT_ID){
      await createNewChat(false);
    }

    if(!currentChatId){
      await createNewChat(false);
    }

    messagesCache[currentChatId] = messagesCache[currentChatId] || [];

    const historyForServer = (messagesCache[currentChatId] || []).map(m => ({
      role: m.role,
      content: m.text || ''
    }));

    const userMsg = { role:'user', text, time: Date.now() };
    messagesCache[currentChatId].push(userMsg);

    if(!ephemeralChats.has(currentChatId)){
      await saveConversationToServer(currentChatId);
    }

    renderMessagesForCurrentChat();
    input.value = '';

    const typingDiv = document.createElement('div');
    typingDiv.className = 'chat-message';
    typingDiv.innerHTML = `<div class="bot" style="font-style:italic;color:#6b7280;border-style:dashed;">BundleAI is thinking...</div>`;
    chatColumn.appendChild(typingDiv);
    typingDiv.scrollIntoView({behavior:'smooth'});

    try {
      const res = await fetch('/chat', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({
          message: text,
          sid: SESSION_ID,
          chat_id: currentChatId,
          history: historyForServer
        })
      });
      const data = await res.json();
      typingDiv.remove();

      const replyText = data.reply || '(no reply)';
      const table_html = data.table_html || '';
      const plot_data_uri = data.plot_data_uri || data.plot_uri || '';
      const download_url = data.download_url || null;

      const botMsg = {
        role:'bot',
        text: replyText,
        table_html,
        plot_data_uri,
        download_url,
        time: Date.now()
      };
      messagesCache[currentChatId].push(botMsg);

      if(!ephemeralChats.has(currentChatId)){
        await saveConversationToServer(currentChatId);
      }

      const firstUser = messagesCache[currentChatId].find(m => m.role==='user');
      if(!ephemeralChats.has(currentChatId) && chatsIndex[currentChatId]){
        chatsIndex[currentChatId].title = firstUser ? (firstUser.text.slice(0,40) + (firstUser.text.length>40 ? '...' : '')) : 'Chat';
      }
      setTopHeaderTitle((chatsIndex[currentChatId] && chatsIndex[currentChatId].title) || 'Chat');

      renderChatList();
      renderMessagesForCurrentChat();
    } catch(err){
      typingDiv.remove();
      const errMsg = { role:'bot', text: '⚠️ Error connecting to server: ' + (err.message || err), time: Date.now() };
      messagesCache[currentChatId].push(errMsg);
      if(!ephemeralChats.has(currentChatId)){
        await saveConversationToServer(currentChatId);
      }
      renderMessagesForCurrentChat();
    }
  }

  // Run a sample question and show answer in SAME PLACE (replace Run pill)
  async function runSampleAt(userMsgIndex){
    try{
      if(currentChatId !== SAMPLE_CHAT_ID) return;

      const arr = messagesCache[currentChatId] || [];
      const msg = arr[userMsgIndex];
      if(!msg || msg.role !== 'user') return;

      const question = (msg.text || '').trim();
      if(!question) return;

      // If already has a bot answer immediately after it, don't duplicate
      if(userMsgIndex + 1 < arr.length && arr[userMsgIndex + 1] && arr[userMsgIndex + 1].role === 'bot'){
        renderMessagesForCurrentChat();
        return;
      }

      // Build history for server
      const historyForServer = arr.map(m => ({
        role: m.role,
        content: m.text || ''
      }));

      // Insert placeholder bot right after this user message
      const placeholder = {
        role: 'bot',
        text: 'BundleAI is thinking...',
        table_html: '',
        plot_data_uri: null,
        download_url: null,
        time: Date.now(),
        __placeholder: true
      };

      arr.splice(userMsgIndex + 1, 0, placeholder);
      messagesCache[currentChatId] = arr;
      renderMessagesForCurrentChat();

      const res = await fetch('/chat', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({
          message: question,
          sid: SESSION_ID,
          chat_id:"sample-ephemeral",
          history: historyForServer
        })
      });

      const data = await res.json();

      const replyText = data.reply || '(no reply)';
      const table_html = data.table_html || '';
      const plot_data_uri = data.plot_data_uri || data.plot_uri || '';
      const download_url = data.download_url || null;

      const finalBot = {
        role:'bot',
        text: replyText,
        table_html,
        plot_data_uri,
        download_url,
        time: Date.now()
      };

      // Replace placeholder that is directly after the user message
      const arr2 = messagesCache[currentChatId] || [];
      if(userMsgIndex + 1 < arr2.length && arr2[userMsgIndex + 1] && arr2[userMsgIndex + 1].__placeholder){
        arr2[userMsgIndex + 1] = finalBot;
      } else {
        const idx = arr2.findIndex(m => m && m.__placeholder);
        if(idx !== -1) arr2[idx] = finalBot;
        else arr2.splice(userMsgIndex + 1, 0, finalBot);
      }

      messagesCache[currentChatId] = arr2;
      renderMessagesForCurrentChat();

    } catch(err){
      console.warn('runSampleAt error', err);
      const arr = messagesCache[currentChatId] || [];
      const idx = arr.findIndex(m => m && m.__placeholder);
      if(idx !== -1){
        arr[idx] = { role:'bot', text:'⚠️ Error connecting to server: ' + (err.message || err), time: Date.now() };
        messagesCache[currentChatId] = arr;
        renderMessagesForCurrentChat();
      }
    }
  }

  sendBtn.addEventListener('click', sendMessage);
  input.addEventListener('keypress', (e) => { if(e.key === 'Enter') sendMessage(); });
  sampleBtn.addEventListener('click', async () => {
    // Force a fresh reload every time (so it always shows again)
    delete messagesCache[SAMPLE_CHAT_ID];
    await loadConversation(SAMPLE_CHAT_ID);
  });
  // initial load
  loadChatsIndex();
</script>
</body>
</html>
